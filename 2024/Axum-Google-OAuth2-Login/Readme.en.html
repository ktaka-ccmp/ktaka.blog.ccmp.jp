<!-- Implementing Google OAuth2/OIDC with Axum -->
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#overview">Overview</a>
<ul>
<li><a href="#what-are-oauth2-and-openid-connect">What Are OAuth2 and
OpenID Connect?</a></li>
<li><a href="#how-authentication-works-key-concepts">How Authentication
Works: Key Concepts</a></li>
</ul></li>
<li><a href="#implementation-details">Implementation Details</a>
<ul>
<li><a href="#authentication-flow">Authentication Flow</a></li>
<li><a href="#route-structure">Route Structure</a></li>
<li><a href="#main-page-behavior">Main Page Behavior</a></li>
<li><a href="#initiating-the-oauth2-flow">Initiating the OAuth2
Flow</a></li>
<li><a href="#handling-oauth2-callback">Handling OAuth2
Callback</a></li>
<li><a href="#managing-user-sessions">Managing User Sessions</a></li>
</ul></li>
<li><a href="#security-considerations">Security Considerations</a>
<ul>
<li><a href="#nonce-validation">Nonce Validation</a></li>
<li><a href="#csrf-protection">CSRF Protection</a></li>
<li><a href="#cookie-security">Cookie Security</a></li>
<li><a href="#response-mode-security">Response Mode Security</a></li>
<li><a
href="#authentication-with-authorization-code-flow">Authentication with
Authorization Code Flow</a></li>
<li><a href="#id-token-validation">ID Token Validation</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Modern web applications often rely on OAuth2/OIDC for secure user
authentication. As part of a recent exploration into Rust and Axum, I
implemented a login system that integrates Google OAuth2. In this post,
I’ll walk through the details of the implementation, covering both the
theoretical aspects and practical steps involved in building a secure
authentication system.</p>
<p>To keep things concise, I’ve included simplified code snippets for
key components. The full implementation is available in my <a
href="https://github.com/ktaka-ccmp/axum-google-oauth2">GitHub
repository</a>.</p>
<p>
    <video width="600" height="600" src="https://github.com/ktaka-ccmp/ktaka.blog.ccmp.jp/raw/refs/heads/master/2024/Axum-Google-OAuth2-Login/image/blog-20241206-02.mp4" controls="true" autoplay loop></video>
</p>
<h2 id="overview">Overview</h2>
<h3 id="what-are-oauth2-and-openid-connect">What Are OAuth2 and OpenID
Connect?</h3>
<p>OAuth2 and OpenID Connect (OIDC) are key to modern authentication
systems, and understanding how they fit together can make implementing
secure authentication easier.</p>
<p>OAuth2 serves as a foundation, allowing users to grant applications
access to their resources without sharing credentials. Applications
interact with these resources through access tokens. For this
implementation, I used the authorization code flow, a secure and widely
adopted approach, to retrieve user information from the identity
provider.</p>
<p>OIDC builds on OAuth2, adding a standardized layer for
authentication. While OAuth2 focuses on “what can this app access?”,
OIDC answers “who is this user?” It introduces the ID token, a JSON Web
Token (JWT) that contains verified user identity information. This makes
it possible to authenticate users while managing access permissions in a
single, unified flow.</p>
<p>In a nutshell, OAuth2 becomes more secure when extended with the ID
token under the OIDC standard.</p>
<h3 id="how-authentication-works-key-concepts">How Authentication Works:
Key Concepts</h3>
<h4 id="basic-authentication-flow">Basic Authentication Flow</h4>
<p>This implementation follows a well-defined sequence for
authentication:</p>
<p><a href="https://raw.githubusercontent.com/ktaka-ccmp/ktaka.blog.ccmp.jp/master/2024/Axum-Google-OAuth2-Login/image/fig-1.png"
    target="_blank">
    <img src="https://raw.githubusercontent.com/ktaka-ccmp/ktaka.blog.ccmp.jp/master/2024/Axum-Google-OAuth2-Login/image/fig-1.png"
    width="80%" alt="basic-authentication-flow" title="basic-authentication-flow"> </a></p>
<p>The process begins when a user clicks the login button, which opens a
popup and redirects to Google’s authentication page. After a successful
login, Google returns an authorization code that the server exchanges
for tokens. The server verifies ID token, creates a user session, and
sets a session cookie in the response to the browser, completing the
authentication flow. The user is subsequently identified by this cookie
in all future requests.</p>
<h4 id="how-session-cookies-work">How Session Cookies Work</h4>
<p>Session cookies play a central role in maintaining authenticated
access. Once the server sets a session cookie during login, it is
automatically included in future browser requests. To ensure secure
session management, I used several measures:</p>
<ul>
<li><strong>HttpOnly flag</strong>: Prevents client-side script access
to cookies.</li>
<li><strong>Secure flag</strong>: Ensures cookies are only transmitted
over HTTPS.</li>
<li><strong>SameSite settings</strong>: Protects against CSRF
attacks.</li>
<li><strong><code>__Host-</code> prefix:</strong> Enforces HTTPS and
host-specific restrictions.</li>
</ul>
<p>These settings work together to maintain secure authentication
states, even across multiple tabs.</p>
<h4 id="oauth2-parameters">OAuth2 Parameters</h4>
<p>OAuth2 and OIDC define several parameters critical to the
authentication process. Here’s how I approached configuring some of the
key parameters:</p>
<ul>
<li><strong><code>response_type</code></strong>: Set to
<code>code</code>, as it securely delivers an authorization code.</li>
<li><strong><code>response_mode</code></strong>: Used
<code>form_post</code> for better security by avoiding sensitive data in
URLs.</li>
<li><strong><code>scope</code></strong>: Requested <code>openid</code>,
<code>email</code>, and <code>profile</code> for user identity and basic
information.</li>
</ul>
<p>These parameters are essential for controlling the authentication
flow and ensuring security.</p>
<h2 id="implementation-details">Implementation Details</h2>
<p>The following sections break down the implementation into key
components, explaining how the OAuth2 authentication flow integrates
with session management and security mechanisms.</p>
<h3 id="authentication-flow">Authentication Flow</h3>
<p>Our implementation uses a popup window for authentication to keep the
main page responsive. This approach:</p>
<ul>
<li>Handles the auth flow in a separate window</li>
<li>Maintains login state using shared cookies across the windows</li>
<li>Updates the main page automatically when complete</li>
</ul>
<p>The flow coordinates between four components: browser, server,
Google, and session store. The session store manages login sessions and
security tokens (CSRF and nonce).</p>
<p><a href="https://raw.githubusercontent.com/ktaka-ccmp/ktaka.blog.ccmp.jp/master/2024/Axum-Google-OAuth2-Login/image/fig-2.png"
    target="_blank">
    <img src="https://raw.githubusercontent.com/ktaka-ccmp/ktaka.blog.ccmp.jp/master/2024/Axum-Google-OAuth2-Login/image/fig-2.png"
    width="80%" alt="authentication-flow" title="authentication-flow"> </a></p>
<p>This diagram captures the flow of data and interactions at each
step.</p>
<h3 id="route-structure">Route Structure</h3>
<p>The application defines routes to manage each step of the
authentication and session flow:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> app <span class="op">=</span> <span class="pp">Router::</span>new()</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>route(<span class="st">&quot;/&quot;</span><span class="op">,</span> get(index))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>route(<span class="st">&quot;/auth/google&quot;</span><span class="op">,</span> get(google_auth))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>route(<span class="st">&quot;/auth/authorized&quot;</span><span class="op">,</span> get(get_authorized)<span class="op">.</span>post(post_authorized))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>route(<span class="st">&quot;/popup_close&quot;</span><span class="op">,</span> get(popup_close))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>route(<span class="st">&quot;/logout&quot;</span><span class="op">,</span> get(logout))</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>route(<span class="st">&quot;/protected&quot;</span><span class="op">,</span> get(protected))<span class="op">;</span></span></code></pre></div>
<h3 id="main-page-behavior">Main Page Behavior</h3>
<p>The main page dynamically adjusts its content based on the user’s
authentication status:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> index(user<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span>User<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="kw">impl</span> IntoResponse <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> user <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Some</span>(u) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> message <span class="op">=</span> <span class="pp">format!</span>(<span class="st">&quot;Hey {}! You&#39;re logged in!&quot;</span><span class="op">,</span> u<span class="op">.</span>name)<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> template <span class="op">=</span> IndexTemplateUser <span class="op">{</span> message<span class="op">:</span> <span class="op">&amp;</span>message <span class="op">};</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            (<span class="pp">StatusCode::</span>OK<span class="op">,</span> Html(template<span class="op">.</span>render()<span class="op">.</span>unwrap()))<span class="op">.</span>into_response()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cn">None</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> message <span class="op">=</span> <span class="st">&quot;You&#39;re not logged in.</span><span class="sc">\n</span><span class="st">Click the Login button below.&quot;</span><span class="op">.</span>to_string()<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> template <span class="op">=</span> IndexTemplateAnon <span class="op">{</span> message<span class="op">:</span> <span class="op">&amp;</span>message <span class="op">};</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            (<span class="pp">StatusCode::</span>OK<span class="op">,</span> Html(template<span class="op">.</span>render()<span class="op">.</span>unwrap()))<span class="op">.</span>into_response()</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>For authenticated users: Displays a personalized greeting.</li>
<li>For anonymous users: Displays a login button to trigger the
popup-based authentication flow.</li>
</ul>
<h3 id="initiating-the-oauth2-flow">Initiating the OAuth2 Flow</h3>
<p>The <code>/auth/google</code> endpoint initiates the OAuth2 flow:</p>
<ol type="1">
<li>Generates security tokens (CSRF and nonce).</li>
<li>Stores these tokens in the session.</li>
<li>Redirects the browser to Google’s authentication page.</li>
</ol>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> google_auth(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    State(params)<span class="op">:</span> State<span class="op">&lt;</span>OAuth2Params<span class="op">&gt;,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    State(store)<span class="op">:</span> State<span class="op">&lt;</span>MemoryStore<span class="op">&gt;,</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    headers<span class="op">:</span> HeaderMap<span class="op">,</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="kw">impl</span> IntoResponse<span class="op">,</span> AppError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Generate and store security tokens</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (csrf_token<span class="op">,</span> csrf_id) <span class="op">=</span> generate_store_token(<span class="st">&quot;csrf_session&quot;</span><span class="op">,</span> expires_at<span class="op">,</span> <span class="cn">Some</span>(user_agent))<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (nonce_token<span class="op">,</span> nonce_id) <span class="op">=</span> generate_store_token(<span class="st">&quot;nonce_session&quot;</span><span class="op">,</span> expires_at<span class="op">,</span> <span class="cn">None</span>)<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Combine tokens into a state parameter</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> encoded_state <span class="op">=</span> encode_state(csrf_token<span class="op">,</span> nonce_id)<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Construct the Google OAuth2 URL with required parameters</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> auth_url <span class="op">=</span> <span class="pp">format!</span>(</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;{}?{}&amp;client_id={}&amp;redirect_uri={}&amp;state={}&amp;nonce={}&quot;</span><span class="op">,</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        OAUTH2_AUTH_URL<span class="op">,</span>         <span class="co">// e.g., https://accounts.google.com/o/oauth2/v2/auth</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        OAUTH2_QUERY_STRING<span class="op">,</span>     <span class="co">// e.g., response_type=code&amp;scope=openid+email+profile...</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        params<span class="op">.</span>client_id<span class="op">,</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        params<span class="op">.</span>redirect_uri<span class="op">,</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        encoded_state<span class="op">,</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        nonce_token</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set security cookie and prepare the redirect response</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> headers <span class="op">=</span> <span class="pp">HeaderMap::</span>new()<span class="op">;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    header_set_cookie(<span class="op">&amp;</span><span class="kw">mut</span> headers<span class="op">,</span> CSRF_COOKIE_NAME<span class="op">,</span> csrf_id<span class="op">,</span> expires_at)<span class="op">?;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>((headers<span class="op">,</span> <span class="pp">Redirect::</span>to(<span class="op">&amp;</span>auth_url)))</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="state-parameter">State Parameter</h4>
<p>The state parameter combines:</p>
<ul>
<li>CSRF token: Protects against cross-site request forgery.</li>
<li>Nonce ID: Validates the ID token’s authenticity.</li>
<li>Base64URL encoding: Embeds multiple parameters in a URL safe single
parameter.</li>
</ul>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> encode_state(csrf_token<span class="op">:</span> <span class="dt">String</span><span class="op">,</span> nonce_id<span class="op">:</span> <span class="dt">String</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> state_params <span class="op">=</span> StateParams <span class="op">{</span> csrf_token<span class="op">,</span> nonce_id <span class="op">};</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    URL_SAFE<span class="op">.</span>encode(<span class="pp">serde_json::json!</span>(state_params)<span class="op">.</span>to_string())</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Google preserves and returns this state parameter unchanged, enabling
security validations in the callback.</p>
<h3 id="handling-oauth2-callback">Handling OAuth2 Callback</h3>
<p>After the user authenticates with Google, the application must
process the callback to complete the authentication process. This
includes exchanging the authorization code for tokens and validating
their authenticity.</p>
<p>Google returns the user’s authentication data via the
<code>/auth/authorized</code> endpoint. This endpoint supports two
modes:</p>
<h4 id="form-post-moderecommended">Form Post Mode(Recommended)</h4>
<p>Google returns the authorization code and state to the browser. A
Google-provided javascript sends them to the endpoint as POST body. They
are processed by:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> post_authorized(</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    State(state)<span class="op">:</span> State<span class="op">&lt;</span>AppState<span class="op">&gt;,</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    Form(form)<span class="op">:</span> Form<span class="op">&lt;</span>AuthResponse<span class="op">&gt;,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="kw">impl</span> IntoResponse<span class="op">,</span> AppError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    validate_origin(<span class="op">&amp;</span>headers<span class="op">,</span> <span class="op">&amp;</span>state<span class="op">.</span>oauth2_params<span class="op">.</span>auth_url)<span class="op">.</span><span class="kw">await</span><span class="op">?;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    authorized(<span class="op">&amp;</span>form<span class="op">,</span> state)<span class="op">.</span><span class="kw">await</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="query-mode">Query Mode</h4>
<p>Google returns a redirect response with the authorization code and
state as URL query parameters. They are processed by:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> get_authorized(</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    Query(query)<span class="op">:</span> Query<span class="op">&lt;</span>AuthResponse<span class="op">&gt;,</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    State(state)<span class="op">:</span> State<span class="op">&lt;</span>AppState<span class="op">&gt;,</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    TypedHeader(cookies)<span class="op">:</span> TypedHeader<span class="op">&lt;</span><span class="pp">headers::</span>Cookie<span class="op">&gt;,</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="kw">impl</span> IntoResponse<span class="op">,</span> AppError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    csrf_checks(cookies<span class="op">.</span>clone()<span class="op">,</span> <span class="op">&amp;</span>state<span class="op">.</span>store<span class="op">,</span> <span class="op">&amp;</span>query<span class="op">,</span> headers)<span class="op">.</span><span class="kw">await</span><span class="op">?;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    authorized(<span class="op">&amp;</span>query<span class="op">,</span> state)<span class="op">.</span><span class="kw">await</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Both callback modes eventually process the authentication response
through the authorized function. This function exchanges the code for
tokens, verifies their authenticity, and establishes a user session.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> authorized(auth_response<span class="op">:</span> <span class="op">&amp;</span>AuthResponse<span class="op">,</span> state<span class="op">:</span> AppState) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="kw">impl</span> IntoResponse<span class="op">,</span> AppError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (access_token<span class="op">,</span> id_token) <span class="op">=</span> exchange_code_for_token(<span class="op">...</span>)<span class="op">.</span><span class="kw">await</span><span class="op">?;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> user_data <span class="op">=</span> user_from_verified_idtoken(id_token<span class="op">,</span> <span class="op">&amp;</span>state<span class="op">,</span> auth_response)<span class="op">.</span><span class="kw">await</span><span class="op">?;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Optional check for user data from userinfo endpoint</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> user_data_userinfo <span class="op">=</span> fetch_user_data_from_google(access_token)<span class="op">.</span><span class="kw">await</span><span class="op">?;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> user_data<span class="op">.</span>id <span class="op">!=</span> user_data_userinfo<span class="op">.</span>id <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="cn">Err</span>(<span class="pp">anyhow::anyhow!</span>(<span class="st">&quot;ID mismatch&quot;</span>)<span class="op">.</span>into())<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> session_id <span class="op">=</span> create_and_store_session(user_data<span class="op">,</span> <span class="op">...</span>)<span class="op">.</span><span class="kw">await</span><span class="op">?;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>((set_cookie_header(session_id)<span class="op">,</span> <span class="pp">Redirect::</span>to(<span class="st">&quot;/popup_close&quot;</span>)))</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="managing-user-sessions">Managing User Sessions</h3>
<p>Sessions ensure secure, consistent authentication across requests.
Upon successful login, a session is created and securely stored:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> create_and_store_session(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    user_data<span class="op">:</span> User<span class="op">,</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    store<span class="op">:</span> <span class="op">&amp;</span>MemoryStore<span class="op">,</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    expires_at<span class="op">:</span> DateTime<span class="op">&lt;</span>Utc<span class="op">&gt;,</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> AppError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> session <span class="op">=</span> <span class="pp">Session::</span>new()<span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    session<span class="op">.</span>insert(<span class="st">&quot;user&quot;</span><span class="op">,</span> <span class="op">&amp;</span>user_data)<span class="op">?;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    session<span class="op">.</span>set_expiry(expires_at)<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> session_id <span class="op">=</span> store<span class="op">.</span>store_session(session)<span class="op">.</span><span class="kw">await</span><span class="op">?;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(session_id)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To protect sensitive routes, the function arguments include
<code>user: User</code>. The <code>User</code> extractor automatically
verifies the session cookie and retrieves the user data for subsequent
requests:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The &quot;user: User&quot; argument ensures access to authenticated user data.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> protected(user<span class="op">:</span> User) <span class="op">-&gt;</span> <span class="kw">impl</span> IntoResponse <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">format!</span>(<span class="st">&quot;Welcome, {}!&quot;</span><span class="op">,</span> user<span class="op">.</span>name)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">// The User extractor</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Extract cookie from the request, and retrieve user data from the session store</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>async_trait<span class="at">]</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>S<span class="op">&gt;</span> FromRequestParts<span class="op">&lt;</span>S<span class="op">&gt;</span> <span class="cf">for</span> User</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    MemoryStore<span class="op">:</span> FromRef<span class="op">&lt;</span>S<span class="op">&gt;,</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    S<span class="op">:</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span><span class="op">,</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">async</span> <span class="kw">fn</span> from_request_parts(parts<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Parts<span class="op">,</span> state<span class="op">:</span> <span class="op">&amp;</span>S) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">Self</span><span class="op">,</span> <span class="dt">Self</span><span class="pp">::</span>Rejection<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> store <span class="op">=</span> <span class="pp">MemoryStore::</span>from_ref(state)<span class="op">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> session_cookie <span class="op">=</span> get_session_cookie(parts)<span class="op">?;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> user <span class="op">=</span> load_user_from_session(store<span class="op">,</span> session_cookie)<span class="op">.</span><span class="kw">await</span><span class="op">?;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(user)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="security-considerations">Security Considerations</h2>
<p>Our authentication implementation relies on several security
mechanisms working together. Since we use ID token claims for
authentication, these mechanisms focus on protecting the authentication
process and verifying token authenticity.</p>
<h3 id="nonce-validation">Nonce Validation</h3>
<p>The nonce mechanism is crucial for verifying that the ID token we’ll
use for authentication was issued specifically for this request.</p>
<p>Nonce validation confirms the ID token’s authenticity by comparing
two values:</p>
<ol type="1">
<li><strong>Nonce in the ID token:</strong> Embedded by Google in the
signed token.</li>
<li><strong>Nonce from the session store:</strong> Retrieved using the
<code>nonce_id</code> from the state parameter.</li>
</ol>
<p>This prevents replay attacks and ensures the token is tied to the
current authentication request.</p>
<p><a href="https://raw.githubusercontent.com/ktaka-ccmp/ktaka.blog.ccmp.jp/master/2024/Axum-Google-OAuth2-Login/image/fig-3.png"
    target="_blank">
    <img src="https://raw.githubusercontent.com/ktaka-ccmp/ktaka.blog.ccmp.jp/master/2024/Axum-Google-OAuth2-Login/image/fig-3.png"
    width="80%" alt="nonce-validation" title="nonce-validation"> </a></p>
<h3 id="csrf-protection">CSRF Protection</h3>
<p>Cross-Site Request Forgery (CSRF) protection ensures that
authentication callbacks come from legitimate auth flows initiated by
our application. Without it, malicious sites could trick authenticated
users into unwanted auth requests.</p>
<p>The security mechanism differs between response modes due to how
browsers handle redirects versus direct POST requests:</p>
<p><strong>Query Mode Flow:</strong></p>
<p>This mode requires cookie-based CSRF validation because the callback
comes as a browser redirect, which could originate from any site. The
CSRF token ensures the request chain started with our application:</p>
<p><a href="https://raw.githubusercontent.com/ktaka-ccmp/ktaka.blog.ccmp.jp/master/2024/Axum-Google-OAuth2-Login/image/fig-4.png"
    target="_blank">
    <img src="https://raw.githubusercontent.com/ktaka-ccmp/ktaka.blog.ccmp.jp/master/2024/Axum-Google-OAuth2-Login/image/fig-4.png"
    width="80%" alt="csrf-protection" title="csrf-protection"> </a></p>
<p><strong>Form Post Mode:</strong></p>
<p>In this mode, we can’t use CSRF cookie validation because:</p>
<ul>
<li>The callback comes as a cross-origin POST request from Google’s
domain</li>
<li>Browser security blocks our <code>__Host-CsrfId</code> cookie from
being sent with such requests</li>
</ul>
<p>Instead, we rely on two security measures:</p>
<ul>
<li><strong>Nonce validation:</strong> Confirms the ID token was issued
for our specific auth request</li>
<li><strong>Origin validation:</strong> Ensures the POST request comes
from Google’s domain</li>
</ul>
<p>This combination ensures that only Google can respond to our original
authentication request, preventing any malicious sites from initiating
or hijacking the authentication flow.</p>
<h3 id="cookie-security">Cookie Security</h3>
<p>All cookies use comprehensive security settings:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;{name}={value}; SameSite=Lax; Secure; HttpOnly; Path=/; Max-Age={max_age}&quot;</span></span></code></pre></div>
<ul>
<li><strong><code>HttpOnly:</code></strong> Prevents JavaScript access
to cookies.</li>
<li><strong><code>Secure:</code></strong> Ensures transmission occurs
only over HTTPS.</li>
<li><strong><code>SameSite=Lax:</code></strong> Guards against CSRF
while allowing same-origin navigation.</li>
<li><strong><code>__Host-</code> prefix:</strong> Enforces HTTPS and
host-specific restrictions.</li>
</ul>
<p>These settings ensure cookies are protected from common attack
vectors.</p>
<h3 id="response-mode-security">Response Mode Security</h3>
<p><strong>Form Post Mode (Recommended)</strong></p>
<ul>
<li>Authorization code is included in the POST body, keeping it hidden
from URLs and logs.</li>
<li>Security relies on <strong>origin validation</strong> and
<strong>nonce verification</strong> .</li>
<li>The most secure option for production use.</li>
</ul>
<p><strong>Query Mode</strong></p>
<ul>
<li>Authorization code is visible in the URL, making it easier to debug
but more prone to exposure (e.g., logs, bookmarks).</li>
<li>Offers full CSRF protection but carries a higher risk of leakage in
environments where URLs are recorded.</li>
</ul>
<h3 id="authentication-with-authorization-code-flow">Authentication with
Authorization Code Flow</h3>
<p>The authorization code flow (<code>response_type=code</code>) offers
key security advantages:</p>
<ul>
<li><strong>Secure Token Exchange:</strong> Tokens are obtained through
secure server-to-server communication</li>
<li><strong>Security Best Practice:</strong> Recommended approach for
production applications</li>
</ul>
<h3 id="id-token-validation">ID Token Validation</h3>
<p>The ID token, a cryptographically signed JWT, provides secure
authentication through its claims:</p>
<ul>
<li><code>aud</code>: Ensures token was issued for our application</li>
<li><code>iss</code>: Verifies Google as the token issuer</li>
<li><code>exp</code> and <code>iat</code>: Prevent token reuse and
replay attacks</li>
<li><code>nonce</code>: Binds token to our specific auth request</li>
</ul>
<p>While Google’s userinfo endpoint provides similar data, we rely on ID
token validation because:</p>
<ul>
<li>Claims are cryptographically secured by Google’s signature</li>
<li>Validation is faster than additional userinfo requests</li>
<li>Userinfo endpoint is better suited for fetching optional profile
data</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>In this implementation, I’ve walked through building a secure
OAuth2/OIDC authentication system with Axum. While implementing auth can
be complex, breaking it down into manageable components helped create a
system that’s both secure and maintainable. The code demonstrates
practical patterns for token validation, CSRF protection, and session
management that you might find useful in your own projects.</p>
<p>I’ve posted the complete implementation on <a
href="https://github.com/ktaka-ccmp/axum-google-oauth2">GitHub</a>. Take
a look if you’re interested in the implementation details - I’m
particularly curious about your thoughts on the security measures and
session handling approach. If you spot any potential improvements or
have questions about specific design choices, I’d love to hear your
feedback!</p>
