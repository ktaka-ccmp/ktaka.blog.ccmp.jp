# Axumで実装するGoogle OAuth2/OIDC認証システム

- [はじめに](#はじめに)
- [概要](#概要)
  - [OAuth2とOpenID Connectとは](#oauth2とopenid-connectとは)
  - [認証の仕組み：基本概念](#認証の仕組み基本概念)
- [実装の詳細](#実装の詳細)
  - [認証フロー](#認証フロー)
  - [ルート構造](#ルート構造)
  - [メインページの動作](#メインページの動作)
  - [OAuth2フローの開始](#oauth2フローの開始)
  - [OAuth2コールバックの処理](#oauth2コールバックの処理)
  - [セッション管理](#セッション管理)
- [セキュリティの考慮点](#セキュリティの考慮点)
  - [Nonceによる検証](#nonceによる検証)
  - [CSRF対策](#csrf対策)
  - [Cookieのセキュリティ](#cookieのセキュリティ)
  - [レスポンスモードのセキュリティ](#レスポンスモードのセキュリティ)
  - [Authorization Code Flowによる認証](#authorization-code-flowによる認証)
  - [IDトークンの検証](#idトークンの検証)
- [おわりに](#おわりに)

## はじめに

最近のWebアプリケーションでは、セキュアな認証基盤としてOAuth2/OIDCの利用が一般的になっています。本記事では、RustのWebフレームワークであるAxumを使用して、Google OAuth2による認証システムを実装した経験について共有します。実装の詳細や設計上の考慮点を解説しながら、セキュアな認証システムの構築方法について説明します。

コードの理解を助けるため、核となる実装部分を抜粋して紹介します。完全な実装は[GitHubリポジトリ](https://github.com/ktaka-ccmp/axum-google-oauth2)で確認できます。

## 概要

### OAuth2とOpenID Connectとは

現代の認証システムにおいて、OAuth2とOpenID Connect（OIDC）は重要な役割を果たしています。これらの仕組みを理解することで、セキュアな認証システムの実装がより明確になります。

OAuth2は認可の基盤となるフレームワークで、ユーザーが自身の認証情報を直接共有することなく、アプリケーションにリソースへのアクセスを許可することができます。アプリケーションは access token を使用してこれらのリソースにアクセスします。本実装では、セキュアで広く採用されている authorization code flow を使用しています。

OIDCはOAuth2を拡張し、標準化された認証レイヤーを追加します。OAuth2が「このアプリケーションに何を許可するか」に焦点を当てているのに対し、OIDCは「このユーザーは誰か」を証明します。OIDCではID token（JWT形式）を導入し、検証可能なユーザー識別情報を提供します。これにより、認証とアクセス権限の管理を単一のフローで実現できます。

つまり、OIDCによってID tokenが追加されることで、OAuth2はより安全な認証基盤となります。

### 認証の仕組み：基本概念

#### 基本的な認証フロー

この実装では、以下のような認証シーケンスを採用しています：

[mermaid diagram stays as-is]

認証プロセスは、ユーザーがログインボタンをクリックすることから始まります。ポップアップウィンドウが開き、Googleの認証ページにリダイレクトされます。ユーザーが認証を完了すると、Googleは authorization code を返却します。サーバーはこのコードを使用してトークンを取得し、ID tokenを検証してユーザーセッションを作成します。セッションクッキーがブラウザに設定され、以後このクッキーによってユーザーの認証状態が維持されます。

#### セッションクッキーの仕組み

認証状態の維持において、セッションクッキーは中心的な役割を果たします。ログイン時にサーバーが設定したセッションクッキーは、その後のリクエストに自動的に含まれます。セキュアなセッション管理のため、以下の対策を実装しています：

- **HttpOnly フラグ**: クライアントサイドのスクリプトからクッキーへのアクセスを防止
- **Secure フラグ**: HTTPS経由の通信のみを許可
- **SameSite 設定**: CSRF攻撃からの保護
- **`__Host-` プレフィックス**: HTTPSの強制とホスト固有の制限の適用

これらの設定により、複数タブにまたがる安全な認証状態の維持が可能になります。

#### OAuth2のパラメータ設定

OAuth2とOIDCでは、認証プロセスを制御するための重要なパラメータが定義されています。本実装では以下のように設定しています：

- **`response_type`**: `code`を指定し、authorization codeの安全な受け渡しを実現
- **`response_mode`**: `form_post`を使用し、URLへの機密情報の露出を回避
- **`scope`**: `openid`, `email`, `profile`を指定し、ユーザー識別に必要な情報を取得

これらのパラメータは、認証フローの制御とセキュリティの確保に重要な役割を果たします。

## 実装の詳細

以下のセクションでは、OAuth2認証フローをセッション管理やセキュリティメカニズムと統合する実装の詳細について説明します。

### 認証フロー

本実装ではポップアップウィンドウを使用して認証を行います。この方式には以下の利点があります：

- 認証処理をメインページとは別のウィンドウで実行
- 共有クッキーによるログイン状態の維持
- 認証完了時のメインページの自動更新

フローは、ブラウザ、サーバー、Google、セッションストアの4つのコンポーネント間で連携します。セッションストアはログインセッションとセキュリティトークン（CSRFトークンとnonce）を管理します。

[mermaid diagram stays as-is]

この図は、各ステップでのデータの流れと相互作用を示しています。

### ルート構造

アプリケーションは認証とセッションの各ステップを処理するルートを定義します：

[code block with Router stays as-is]

これらのルートにより、認証の開始からセッション管理、ログアウトまでの一連の処理を実現します。

### メインページの動作

メインページは、ユーザーの認証状態に応じて動的にコンテンツを変更します：

[code block with index function stays as-is]

- 認証済みユーザー：パーソナライズされた挨拶を表示
- 未認証ユーザー：ポップアップベースの認証フローを開始するログインボタンを表示

### OAuth2フローの開始

`/auth/google` エンドポイントは、以下の手順で認証フローを開始します：

1. セキュリティトークン（CSRFトークンとnonce）の生成
2. セッションへのトークンの保存
3. Googleの認証ページへのリダイレクト

[code block with google_auth function stays as-is]

#### ステートパラメータ

ステートパラメータには以下の要素が含まれます：

- CSRFトークン：クロスサイトリクエストフォージェリ対策
- Nonce ID：IDトークンの真正性確認
- Base64URLエンコーディング：複数パラメータを単一のURL安全な値として格納

[code block with encode_state function stays as-is]

このパラメータはGoogleによって変更されることなく返却され、コールバック時のセキュリティ検証に使用されます。

### OAuth2コールバックの処理

ユーザーがGoogleで認証を完了すると、アプリケーションは `/auth/authorized` エンドポイントでコールバックを処理します。このエンドポイントは2つのモードをサポートしています：

#### Form Postモード（推奨）

Googleは authorization code とステートパラメータをブラウザに返却し、Google提供のJavaScriptがこれらをPOSTボディとしてエンドポイントに送信します：

[code block with post_authorized function stays as-is]

#### クエリモード

Googleは authorization code とステートパラメータをURLクエリパラメータとして含めたリダイレクトレスポンスを返します：

[code block with get_authorized function stays as-is]

いずれのモードでも、最終的に `authorized` 関数でコードの交換、トークンの検証、ユーザーセッションの確立を行います：

[code block with authorized function stays as-is]

### セッション管理

ログイン成功後、セキュアなセッションを作成して保存します：

[code block with create_and_store_session function stays as-is]

保護されたルートへのアクセスには `user: User` 引数を使用します。`User` extractorはセッションクッキーを自動的に検証し、後続のリクエストのためのユーザーデータを取得します：

[code block with protected function and User extractor stays as-is]

## セキュリティの考慮点

本実装では、IDトークンのクレームを使用した認証を行うため、複数のセキュリティメカニズムを組み合わせて認証プロセスの保護とトークンの真正性確認を行っています。

### Nonceによる検証

Nonceメカニズムは、使用するIDトークンが現在の認証リクエストに対して発行されたものであることを確認する重要な役割を果たします。

Nonceの検証は、以下の2つの値を比較することで行われます：

1. **IDトークン内のNonce**: Googleによって署名されたトークンに埋め込まれた値
2. **セッションストア内のNonce**: ステートパラメータ内のnonce_idを使用して取得

これによりリプレイ攻撃を防ぎ、トークンが現在の認証リクエストに紐付いていることを保証します。

[mermaid diagram stays as-is]

### CSRF対策

クロスサイトリクエストフォージェリ（CSRF）対策は、認証コールバックが正規の認証フローから発行されたものであることを保証します。この保護がないと、悪意のあるサイトが認証済みユーザーに意図しない認証リクエストを送信させる可能性があります。

ブラウザがリダイレクトと直接のPOSTリクエストを異なる方法で扱うため、レスポンスモードによって異なるセキュリティメカニズムを実装しています：

**クエリモード**：
コールバックがブラウザリダイレクトとして到着するため、クッキーベースのCSRF検証が必要です。CSRFトークンにより、リクエストチェーンが本アプリケーションから開始されたことを確認します：

[mermaid diagram for Query Mode Flow stays as-is]

**Form Postモード**：
このモードではCSRFクッキー検証が使用できません：

- コールバックがGoogleドメインからのクロスオリジンPOSTリクエストとして到着
- ブラウザのセキュリティにより、`__Host-CsrfId`クッキーの送信がブロックされる

代わりに、以下の2つのセキュリティ対策を採用しています：

- **Nonce検証**: IDトークンが我々の認証リクエストに対して発行されたことを確認
- **オリジン検証**: POSTリクエストがGoogleドメインから送信されたことを確認

この組み合わせにより、正規の認証リクエストに対してGoogleのみが応答可能となり、悪意のあるサイトによる認証フローの開始や乗っ取りを防止します。

### Cookieのセキュリティ

すべてのクッキーに包括的なセキュリティ設定を適用しています：

[code block with cookie settings stays as-is]

- **`HttpOnly`**: JavaScriptからのクッキーへのアクセスを防止
- **`Secure`**: HTTPS経由の通信のみを許可
- **`SameSite=Lax`**: CSRF対策と同一オリジンナビゲーションの許可を両立
- **`__Host-` プレフィックス**: HTTPSの強制とホスト固有の制限を適用

これらの設定により、一般的な攻撃ベクトルからクッキーを保護します。

### レスポンスモードのセキュリティ

**Form Postモード（推奨）**
- Authorization code がPOSTボディに含まれ、URLやログに露出しない
- オリジン検証とNonce検証によるセキュリティ確保
- 本番環境で推奨される最も安全な選択肢

**クエリモード**
- Authorization code がURLに露出し、デバッグは容易だが漏洩リスクが高い
- 完全なCSRF保護を提供するが、URLが記録される環境でのリスクが高い

### Authorization Code Flowによる認証

Authorization Code Flow（`response_type=code`）には以下の重要なセキュリティ上の利点があります：

- **セキュアなトークン交換**: サーバー間の安全な通信でトークンを取得
- **セキュリティベストプラクティス**: 本番環境での推奨アプローチ

### IDトークンの検証

IDトークン（暗号署名付きJWT）は、以下のクレームによって安全な認証を提供します：

- `aud`: トークンが本アプリケーション向けに発行されたことを確認
- `iss`: 発行者がGoogleであることを確認
- `exp`と`iat`: トークンの再利用とリプレイ攻撃を防止
- `nonce`: トークンを特定の認証リクエストに紐付け

UserinfoエンドポイントでもIDトークンと同様のデータを取得可能ですが、IDトークンの検証を優先する理由は以下の通りです：

- クレームがGoogleの署名により暗号的に保護されている
- 追加のUserinfoリクエストなしで検証が可能
- Userinfoエンドポイントはオプションのプロファイルデータ取得に適している

## おわりに

本実装では、Axumを使用してセキュアなOAuth2/OIDC認証システムを構築する方法を解説しました。認証の実装は複雑になりがちですが、各コンポーネントに分割することで、セキュアで保守性の高いシステムを実現できました。このコードベースは、トークン検証、CSRF対策、セッション管理などの実践的なパターンを示しています。

完全な実装は[GitHub](https://github.com/ktaka-ccmp/axum-google-oauth2)で公開しています。セキュリティ対策やセッション管理アプローチについて、特に興味を持っていただけると幸いです。改善の提案や設計上の選択についての質問など、フィードバックをお待ちしています。
